---
title: "Upskill and Upgrade"
author: Santhosh Thottingal
type: post
date: 2025-04-15T05:00:00+05:30
url: /blog/2025/07/07/upgrade/
categories:
  - Personal
---

In April 2024, I took a two-month sabbatical from work. During this time, and in the year that followed, I dedicated significant effort to improving my skills. Having spent nearly 20 years in software engineering, I've witnessed substantial changes in the field. Opportunities to learn and practice new skills don't always arise naturally at work. While I made a conscious effort to dedicate time each day to reading and learning, finding time for hands-on practice was a challenge. I set specific goals: to deepen my understanding of system architecture and modern design approaches, explore high-performance programming, and integrate AI into my development process. Hereâ€™s an update on my progress:

I started using AI-assisted coding tools and have deeply integrated them into my daily workflow. Specifically, I began using [GitHub Copilot](https://github.com/features/copilot) with [VS Code](https://code.visualstudio.com/). Thanks to GitHub's open-source support program, I received a free Copilot license. This single change has boosted my productivity by at least twofold. For experienced software engineers, these tools are incredibly powerful because we already understand the underlying architecture and the trade-offs of different solutions.

I also began learning [Go](https://go.dev/), a compiled, statically typed programming language. I took on some personal projects and rewrote them in Go. Then, I built internal tools for work and practiced designing large-scale systems, such as a "Factoids" system. Along the way, I learned many new concepts and programming styles. I've now reached a solid level of proficiency in Go.

After getting comfortable with Go, I moved on to learning [Rust](https://www.rust-lang.org/). Rust has a reputation for being difficult to learn, but my experience with Go was a significant help. There are many overlapping concepts between the two languages. While Go aims for simplicity, Rust takes a different approach. Rust forces you to think carefully about your code, variables, scope, and how data is passed around. You spend more time at the compilation stage, but once your program compiles successfully, you can be confident it will run correctly without unexpected issues in testing or production. This has been a refreshing and enjoyable experience. After achieving good proficiency in Rust, I found little reason to use Go. Rust addresses all of Go's shortcomings and has a larger ecosystem of libraries.

Learning a high-performance programming language has had some interesting side benefits. It introduced me to many efficient algorithms and optimization techniques that I had previously overlooked when working with higher-level and scripting languages. I also learned about different compilation targets, including how to build web frontends using [WebAssembly (Wasm)](https://webassembly.org/).
Another unexpected benefit was the people I encountered. High-performance programming languages often attract highly productive and intelligent software engineers, and I've had the chance to connect with many of them. Following their work and writings has been incredibly educational.

Being part of this community also sparked my interest in their coding workflows and tools, particularly mouse-free, terminal-based, and very fast coding environments. I had always avoided tools like Emacs and Vi, but I decided to learn and master [Neovim](https://neovim.io/), which is a popular choice among many skilled programmers. It took a significant amount of time and effort, but I now use Neovim for my coding. My current setup includes [Kitty](https://sw.kovidgoyal.net/kitty/) (a terminal emulator), Neovim, [Fzf](https://github.com/junegunn/fzf) (a fuzzy finder), [Ripgrep](https://github.com/BurntSushi/ripgrep) (a fast search tool), [Lazygit](https://github.com/jesseduffield/lazygit) (a Git client), [Tmux](https://github.com/tmux/tmux) (a terminal multiplexer), and other similar high-speed tools. Neovim also has excellent Copilot integration, but I've been using [Aider](https://github.com/paul-gauthier/aider), which integrates well with my other terminal-based tools for AI-assisted programming. Neovim taught me to approach code editing in a more semantic way rather than plain text editing. Thanks to [Tree-sitter](https://tree-sitter.github.io/tree-sitter/) and text objects, every editing operation in the code is semantic and not just text manipulation.

I had been using KDE as my desktop environment for the past 15 years, with some time spent on GNOME as well. Recently, I decided to upgrade to a tiling window manager-based desktop. A few months ago, I moved to [Hyprland](https://hyprland.org/). It has been refreshing to build a comfortable desktop environment tailored to my preferences. The collection of small yet powerful components that make up a desktop environment (e.g., window manager, Hyprpaper, Waybar, Swaync, etc.) and their incredible customizability is quite an experience. It reminds me of the enthusiasm in the early days of the KDE and GNOME development communities. I feel reinvigorated to be part of a highly skilled community of young developers pushing the FOSS-based desktop experience forward.

After a year on this learning journey, I'm definitely more knowledgeable, more productive, and generally more ambitious about tackling challenging problems
