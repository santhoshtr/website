---
title: "Upskill and Upgrade"
author: Santhosh Thottingal
type: post
date: 2025-04-15T05:00:00+05:30
url: /blog/2025/07/07/upgrade/
categories:
  - Personal
---

In April 2024, I took a two months sabbatical from my work. During my sabbatical and an year followed, I spent significant time on improving my skills. Having spent nearly 20 years in software engineering, I've seen significant changes in the field. Opportunities to learn and practice new skills don't always arise naturally at work. While I made a conscious effort to dedicate time each day to reading and learning, finding time for hands-on practice was a challenge. I set myself some goals: to practice and learn system architecture and modern design approaches, explore high-performance programming, and integrate AI into my development process. Hereâ€™s an update on my progress:

I've started using AI-assisted coding tools and have deeply integrated them into my daily work. Specifically, I began using GitHub Copilot with VS Code. Thanks to GitHub's open-source support program, I received a free Copilot license. This single change has boosted my productivity by at least twofold. For experienced software engineers, these tools are incredibly powerful because we already understand the underlying architecture and the advantages and disadvantages of different solutions.

I also began learning Go, a compiled, typed programming language. I took on some personal projects and rewrote them in Go. Then, I built some internal tools for work and practiced designing large-scale systems, like a "Factoids" system. Along the way, I learned many new concepts and different programming styles. I've now reached a solid level of proficiency in Go.

After getting comfortable with Go, I moved on to learning Rust. Rust has a reputation for being difficult to learn, but my experience with Go was a significant help. There are many overlapping concepts between the two languages. While Go aims for simplicity, Rust takes a different approach. Rust forces you to think very carefully about your code, variables, scope, and how data is passed around. You spend more time at the compilation stage, but once your program compiles successfully, you can be very confident that it will run correctly without unexpected issues in testing or production. This has been a refreshing and enjoyable experience. After achieving good proficiency in Rust, I found no reason to use Go.Rust fixes all shortcomings of Go and has larger ecosystem of libraries than Go.

Learning a high-performance programming language has had some interesting side benefits. It introduced me to many efficient algorithms and optimization techniques that I had previously overlooked when working with higher-level and scripting languages. I also learned about different compilation targets, including how to build web frontends using WebAssembly (Wasm).
Another unexpected benefit was the people I encountered. High-performance programming languages often attract highly productive and intelligent software engineers, and I've had the chance to connect with many of them. Following their work and writings has been incredibly educational.

Being part of this community also sparked my interest in their coding workflows and tools, particularly mouse-free, terminal-based, and very fast coding environments. I had always avoided tools like Emacs and Vi, but I decided to learn and master Neovim, which is a popular choice among many skilled programmers. It took a significant amount of time and effort, but I now use Neovim for my coding. My current setup includes Kitty (a terminal emulator), Neovim, Fzf (a fuzzy finder), Ripgrep (a fast search tool), Lazygit (a Git client), Tmux (a terminal multiplexer), and other similar high-speed tools. Neovim also has excellent Copilot integration, but I've been using Aider, which integrates well with my other terminal-based tools for AI-assisted programming. Neovim tought me to approach code editing in more sematic way rather than plain text editing appraoch. Thanks to tree-sitter and text-objects, every editing operation in the code is semantic and no just text editing.

I have been using KDE as my IDE for past 15 years. I had used GNOME as well for sometime. I decided to upgrade to tiling window based desktop. A few months back I moved to Hyprland. It is so refreshing to build a comfortable Desktop enviornment as per your preferences. The collection of small, yet powerful components that make a desktop environment(window manager, hyprpaper, waybar, swaync etc) and their awesome customizability is quite an experience. It reminds me the enthusiasm in early days of KDE, GNOME development communties and I back into the the crowd of high skilled community of young developers trying to move the FOSS based desktop experience forward.

After a year on this learning journey, I'm definitely more knowledgeable, more productive, and generally more ambitious about tackling challenging problems
