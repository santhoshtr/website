---
title: "Upskill and Upgrade"
author: Santhosh Thottingal
type: post
date: 2025-06-07T05:00:00+05:30
url: /blog/2025/06/07/upgrade/
categories:
  - Personal
---

In April 2024, I took a two-month sabbatical from work. During this period, and in the year that followed, I dedicated significant effort to improving my skills. Having spent nearly 20 years in software engineering, I've witnessed substantial changes in the field. Opportunities to learn and practice new skills don't always arise naturally at work. While I made a conscious effort to dedicate time each day to reading and learning, finding time for hands-on practice remained a challenge. I set specific goals: to deepen my understanding of system architecture and modern design approaches, explore high-performance programming, and integrate AI into my development process. Hereâ€™s an update on my progress.

I started using AI-assisted coding tools and have deeply integrated them into my daily workflow. Specifically, I began using [GitHub Copilot](https://github.com/features/copilot) with [VS Code](https://code.visualstudio.com/). Thanks to GitHub's open-source support program, I received a free Copilot license. This single change has boosted my productivity at least twofold. For experienced software engineers, these tools are incredibly powerful because we already understand the underlying architecture and the trade-offs of different solutions.

I also began learning [Go](https://go.dev/), a compiled, statically typed programming language. I took on some personal projects, rewriting them in Go. Subsequently, I built internal tools for work and practiced designing large-scale systems, such as a "[Factoids](https://wiki.thottingal.in/en/wiki/Alan%20Turing)" system. Along the way, I learned many new concepts and programming styles, and I've now reached a solid level of proficiency in Go.

After getting comfortable with Go, I moved on to learning [Rust](https://www.rust-lang.org/). Rust has a reputation for being difficult to learn, but my experience with Go was a significant help, as there are many overlapping concepts between the two languages. While Go aims for simplicity, Rust takes a different approach. It forces you to think carefully about your code, variables, scope, and how data is passed around. You spend more time at the compilation stage, but once your program compiles successfully, you can be confident it will run correctly without unexpected issues in testing or production. This has been a refreshing and enjoyable experience. After achieving good proficiency in Rust, I found little reason to continue using Go. Rust addresses many of Go's perceived shortcomings and boasts a larger ecosystem of libraries.

Learning a high-performance programming language has had some interesting side benefits. It introduced me to many efficient algorithms and optimization techniques that I had previously overlooked when working with higher-level and scripting languages. I also learned about different compilation targets, including building web frontends using [WebAssembly (Wasm)](https://webassembly.org/). Another unexpected benefit was the people I encountered. The communities around high-performance programming languages often attract highly productive and intelligent software engineers, and I've had the chance to connect with many of them. Following their work and writings has been incredibly educational.

Being part of this community also sparked my interest in their coding workflows and tools, particularly mouse-free, terminal-based, and very fast coding environments. I had always avoided tools like [Emacs](https://www.gnu.org/software/emacs/) and [Vi](https://www.vim.org/) (the predecessor to Vim/Neovim), but I decided to learn and master [Neovim](https://neovim.io/), a popular choice among many skilled programmers. It took a significant amount of time and effort, but I now use Neovim for all my coding. My current setup includes [Kitty](https://sw.kovidgoyal.net/kitty/) (a terminal emulator), Neovim, [Fzf](https://github.com/junegunn/fzf) (a fuzzy finder), [Ripgrep](https://github.com/BurntSushi/ripgrep) (a fast search tool), [Lazygit](https://github.com/jesseduffield/lazygit) (a Git client), [Tmux](https://github.com/tmux/tmux) (a terminal multiplexer), and other similar high-speed tools. Neovim also has excellent Copilot integration, but I've recently been using [Aider](https://github.com/paul-gauthier/aider), which integrates well with my other terminal-based tools for AI-assisted programming. Neovim taught me to approach code editing more semantically, rather than as plain text editing. Thanks to [Tree-sitter](https://tree-sitter.github.io/tree-sitter/) and its [text objects](https://www.josean.com/posts/nvim-treesitter-and-textobjects), editing operations become semantic manipulations of code structure, not just text.

I had been using [KDE Plasma](https://kde.org/plasma-desktop/) as my desktop environment for the past 15 years, with some time spent on [GNOME](https://www.gnome.org/) as well. Recently, I decided to upgrade to a tiling window manager-based desktop. A few months ago, I moved to [Hyprland](https://hyprland.org/). It has been refreshing to build a comfortable desktop environment tailored to my preferences. The collection of small yet powerful components that make up such an environment (e.g., window manager, [Hyprpaper](https://wiki.hyprland.org/Hyprland-Ecosystem/Hyprpaper/) (for wallpaper), [Waybar](https://github.com/Alexays/Waybar) (for status bars), [Swaync](https://github.com/ErikReider/SwayNotificationCenter) (for notifications), etc.) and their incredible customizability is quite an experience. It reminds me of the enthusiasm in the early days of the KDE and GNOME development communities. I feel reinvigorated to be part of a highly skilled community of young developers pushing the FOSS-based desktop experience forward.

And, here's a glimpse of my "rice":

![Screenshot of my desktop showing hyprland, nvim](/wp-content/uploads/2025/06/hyprland-hype.webp)

This dedicated period of upskilling has been a profound reminder that in the dynamic world of software engineering, continuous learning is not just beneficial, but essential. The journey has been challenging yet immensely rewarding, and I'm excited to carry this momentum forward, tackling new problems with renewed vigor and an expanded toolkit.
